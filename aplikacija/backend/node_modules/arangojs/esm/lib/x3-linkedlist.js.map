{"version":3,"file":"x3-linkedlist.js","sourceRoot":"","sources":["../../../src/lib/x3-linkedlist.ts"],"names":[],"mappings":"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","sourcesContent":["/**!\r\n * x3-linkedlist\r\n *\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 Benno Drei√üig\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n */\r\n\r\nexport class LinkedListItem<T> {\r\n  /**\r\n   * Item behind this item\r\n   * ```\r\n   * A -> ThisItem -> C\r\n   *                  ^\r\n   * ```\r\n   */\r\n  public behind: LinkedListItem<T> | undefined;\r\n\r\n  /**\r\n   * Item before this item\r\n   * ```\r\n   * A -> ThisItem -> C\r\n   * ^\r\n   * ```\r\n   */\r\n  public before: LinkedListItem<T> | undefined;\r\n\r\n  constructor(\r\n    /**\r\n     * Value of this item\r\n     */\r\n    public value: T,\r\n    /**\r\n     *Function to run on unlink() call. Usually used by LinkedList to fix first and last pointers and reduce length.\r\n     */\r\n    protected unlinkCleanup?: (item: LinkedListItem<T>) => void,\r\n  ) {}\r\n\r\n  /**\r\n   * This will link given LinkListItem behind this item.\r\n   * If there's already a LinkedListItem linked behind, it will be relinked accordingly\r\n   */\r\n  public insertBehind(\r\n    /** LinkListItem to be inserted behind this one */\r\n    item: LinkedListItem<T>,\r\n  ): void {\r\n    item.insertBefore(this);\r\n\r\n    if (this.behind) {\r\n      let itemChainEnd = item;\r\n      while (itemChainEnd.behind) itemChainEnd = itemChainEnd.behind;\r\n\r\n      this.behind.insertBefore(itemChainEnd);\r\n      itemChainEnd.insertBehind(this.behind);\r\n    }\r\n    this.behind = item;\r\n  }\r\n\r\n  /**\r\n   * Unlinks this LinkedListItem and calls unlinkCleanup\r\n   * @see LinkedListItem#unlinkCleanup\r\n   */\r\n  public unlink(\r\n    /** If true, additionally removes the reference to the item before and behind */\r\n    unchain = false,\r\n  ): void {\r\n    if (this.before) this.before.behind = this.behind;\r\n\r\n    if (this.behind) {\r\n      this.behind.before = this.before;\r\n    }\r\n    if (this.unlinkCleanup) {\r\n      this.unlinkCleanup(this);\r\n    }\r\n    this.unlinkCleanup = undefined;\r\n\r\n    if (unchain) {\r\n      this.before = this.behind = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Item given will be inserted before this item.\r\n   * unlinkCleanup will be copied if neccessary.\r\n   * This function is protected, because LinkedListItem's can only be attached behind.\r\n   * @see insertBehind\r\n   */\r\n  protected insertBefore(\r\n    /** LinkListItem to be inserted before this one */\r\n    before: LinkedListItem<T>,\r\n  ): void {\r\n    this.before = before;\r\n    if (!this.unlinkCleanup) {\r\n      this.unlinkCleanup = before.unlinkCleanup;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Implements a linked list structure\r\n * @typeparam T - Type of values within this LinkedList\r\n */\r\nexport class LinkedList<T> {\r\n  /**\r\n   * First item in list\r\n   */\r\n  public first: LinkedListItem<T> | undefined;\r\n\r\n  /**\r\n   * Last item in list\r\n   */\r\n  public last: LinkedListItem<T> | undefined;\r\n\r\n  /**\r\n   * Current length of this LinkedList.\r\n   * Note that this does not work anymore if you for some reason add your own LinkedListItems to LinkedList by hand\r\n   */\r\n  public length = 0;\r\n\r\n  constructor(\r\n    /** Values to be added initially into list */\r\n    values?: Iterable<T> | LinkedList<T>,\r\n  ) {\r\n    if (values) {\r\n      if (values instanceof LinkedList) values = values.values();\r\n\r\n      for (const value of values) {\r\n        this.push(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears this LinkedList.\r\n   * The default complexity is O(1), because it only removes links to the first and last item and resets the length.\r\n   * Note that if any LinkedListItem is still referenced outside the LinkedList, their before and behind fields might\r\n   * still reference the chain, not freeing space.\r\n   *\r\n   * You can set the unchain parameter to true, so every item in the linked list will be unchained,\r\n   * meaning all references to before and behind items will be removed.\r\n   * This increases complexity to O(n), but removes accidental outside references to the full chain.\r\n   */\r\n  public clear(\r\n    /** If `true`, remove link info from every item. Changes complexity to O(n)! */\r\n    unchain = false,\r\n  ): void {\r\n    if (unchain) {\r\n      while (this.first) {\r\n        this.first.unlink(true);\r\n      }\r\n    }\r\n\r\n    this.first = this.last = undefined;\r\n    this.length = 0;\r\n  }\r\n\r\n  /**\r\n   * As Array#every() given callback is called for every element until one call returns falsy or all elements had been processed\r\n   * @returns `false` if there was a falsy response from the callback, `true` if all elements have been processed \"falselesly\"\r\n   * @see Array#every\r\n   */\r\n  public every<C>(\r\n    /** Runs for every item in the LinkedList */\r\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\r\n    /** If given, callback function will be bound to thisArg */\r\n    thisArg?: C,\r\n  ): boolean {\r\n    if (thisArg) {\r\n      callback = callback.bind(thisArg);\r\n    }\r\n\r\n    for (const item of this.keys()) {\r\n      if (!callback(item.value, item, this)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Filters values into a new LinkedList\r\n   * @see Array#filter\r\n   */\r\n  public filter<C>(\r\n    /** decides wether given element should be part of new LinkedList */\r\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\r\n    /** If given, callback function will be bound to thisArg */\r\n    thisArg?: C,\r\n  ): LinkedList<T> {\r\n    if (thisArg) {\r\n      callback = callback.bind(thisArg);\r\n    }\r\n\r\n    const newList: LinkedList<T> = new LinkedList();\r\n    for (const [item, value] of this) {\r\n      if (callback(value, item, this)) {\r\n        newList.push(value);\r\n      }\r\n    }\r\n    return newList;\r\n  }\r\n\r\n  /**\r\n   * Returns value for which given callback returns truthy\r\n   * @see Array#find\r\n   */\r\n  public find<C>(\r\n    /** runs for every value in LinkedList. If it returns truthy, current value is returned. */\r\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\r\n    /** If given, callback function will be bound to thisArg */\r\n    thisArg?: C,\r\n  ): T | undefined {\r\n    if (thisArg) {\r\n      callback = callback.bind(thisArg);\r\n    }\r\n\r\n    for (const [item, value] of this) {\r\n      if (callback(value, item, this)) {\r\n        return value;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the LinkedListItem for which given callback returns truthy\r\n   * @see Array#findIndex\r\n   */\r\n  public findItem<C>(\r\n    /** runs for every LinkedListItem in LinkedList. If it returns truthy, current LinkedListItem is returned. */\r\n    callback: (value: T, item: LinkedListItem<T>, list: this) => boolean,\r\n    /** If given, callback function will be bound to thisArg */\r\n    thisArg?: C,\r\n  ): LinkedListItem<T> | undefined {\r\n    if (thisArg) {\r\n      callback = callback.bind(thisArg);\r\n    }\r\n\r\n    for (const [item, value] of this) {\r\n      if (callback(value, item, this)) {\r\n        return item;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Iterates this LinkedList's items and values\r\n   * @see Array#forEach\r\n   */\r\n  public forEach<C>(\r\n    /** Gets every value in LinkedList once with corresponding LinkedListItem and LinkedList */\r\n    callback: (value: T, item: LinkedListItem<T>, list: this) => void,\r\n    /** If given, callback function will be bound to thisArg */\r\n    thisArg?: C,\r\n  ): void {\r\n    if (thisArg) {\r\n      callback = callback.bind(thisArg);\r\n    }\r\n    for (const [item, value] of this) {\r\n      callback(value, item, this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if value can be found within LinkedList, starting from fromIndex, if given.\r\n   * @returns true if value could be found in LinkedList (respecting fromIndex), false otherwhise\r\n   * @see Array#includes\r\n   */\r\n  public includes(\r\n    /** value to be found in this */\r\n    value: T,\r\n    /** Starting index. Supports negative values for which `this.size - 1 + fromIndex` will be used as starting point. */\r\n    fromIndex = 0,\r\n  ): boolean {\r\n    let current = this.getItemByIndex(fromIndex);\r\n    while (current) {\r\n      if (current.value === value) {\r\n        return true;\r\n      }\r\n      current = current.behind;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Searches forward for given value and returns the first corresponding LinkedListItem found\r\n   * @see Array#indexOf\r\n   */\r\n  public itemOf(\r\n    /** Value to be found */\r\n    searchedValue: T,\r\n    /** Index to start from */\r\n    fromIndex = 0,\r\n  ): LinkedListItem<T> | undefined {\r\n    let current = this.getItemByIndex(fromIndex);\r\n    while (current) {\r\n      if (current.value === searchedValue) {\r\n        return current;\r\n      }\r\n      current = current.behind;\r\n    }\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Searches backwards for given value and returns the first corresponding LinkedListItem found\r\n   * @see Array#indexOf\r\n   */\r\n  public lastItemOf(\r\n    /** Value to be found */\r\n    searchedValue: T,\r\n    /** Index to start from */\r\n    fromIndex = -1,\r\n  ): LinkedListItem<T> | undefined {\r\n    let current = this.getItemByIndex(fromIndex);\r\n    while (current) {\r\n      if (current.value === searchedValue) {\r\n        return current;\r\n      }\r\n      current = current.before;\r\n    }\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Creates a new LinkedList with each of its itesm representing the output of the callback with each item in current LinkedList.\r\n   * @see Array#map\r\n   */\r\n  public map<V, C>(\r\n    /** Gets value, LinkedListeItem and LinkedList. The response will be used as value in the new LinkedList */\r\n    callback: (value: T, item: LinkedListItem<T>, list: this) => V,\r\n    /** If given, callback function will be bound to thisArg */\r\n    thisArg?: C,\r\n  ): LinkedList<V> {\r\n    if (thisArg) {\r\n      callback = callback.bind(thisArg);\r\n    }\r\n    const newList = new LinkedList<V>();\r\n    for (const [item, value] of this) {\r\n      newList.push(callback(value, item, this));\r\n    }\r\n    return newList;\r\n  }\r\n\r\n  /**\r\n   * From Array#reduce on MDN: The reduce() method executes a reducer function (that you provide) on each element of the LinkedList,\r\n   * resulting in a single output value.\r\n   * @see Array#reduce\r\n   */\r\n  public reduce<V>(\r\n    /**\r\n     * Gets first value, current value (starting with the second value), LinkedListeItem and LinkedList.\r\n     * Note that currentItem will be the second item on first call.\r\n     * The response will be used as the next accumulator.\r\n     */\r\n    callback: (\r\n      accumulator: T,\r\n      currentValue: T,\r\n      currentItem: LinkedListItem<T>,\r\n      list: this,\r\n    ) => V,\r\n  ): V;\r\n  public reduce<V>(\r\n    /**\r\n     * Gets initialValue as accumulator initially, LinkedListeItem and LinkedList.\r\n     * The response will be used as the next accumulator.\r\n     */\r\n    callback: (\r\n      accumulator: V,\r\n      currentValue: T,\r\n      currentItem: LinkedListItem<T>,\r\n      list: this,\r\n    ) => V,\r\n    /** Value for the first call of callback */\r\n    initialValue: V,\r\n  ): V;\r\n  public reduce<V>(\r\n    callback: (\r\n      accumulator: V | T,\r\n      currentValue: T,\r\n      currentItem: LinkedListItem<T>,\r\n      list: this,\r\n    ) => V,\r\n    initialValue?: V | T,\r\n  ): V | T {\r\n    let current = this.first;\r\n    if (!current) {\r\n      if (!initialValue) {\r\n        throw new TypeError(\r\n          \"Empty accumulator on empty LinkedList is not allowed.\",\r\n        );\r\n      }\r\n      return initialValue;\r\n    }\r\n\r\n    if (initialValue === undefined) {\r\n      initialValue = current.value;\r\n      if (!current.behind) {\r\n        return initialValue;\r\n      }\r\n      current = current.behind;\r\n    }\r\n\r\n    do {\r\n      initialValue = callback(initialValue, current.value, current, this);\r\n      current = current.behind;\r\n    } while (current);\r\n    return initialValue;\r\n  }\r\n\r\n  /**\r\n   * From Array#reduceRight on MDN: The reduceRight() method applies a function against an accumulator and each value of the LinkedList (from last-to-first)\r\n   * to reduce it to a single value.\r\n   * @see Array#reduceRight\r\n   * @see LinkedList#reduce\r\n   */\r\n  public reduceRight<V>(\r\n    /**\r\n     * Gets the last value, current value (starting with the second-to-last value), LinkedListeItem and LinkedList.\r\n     * Note that currentItem will be the second-to-last item on the first call.\r\n     * The response will be used as the next accumulator.\r\n     */\r\n    callback: (\r\n      accumulator: T,\r\n      currentValue: T,\r\n      currentItem: LinkedListItem<T>,\r\n      list: this,\r\n    ) => V,\r\n  ): V;\r\n  public reduceRight<V>(\r\n    /**\r\n     * Gets initialValue as accumulator initially, LinkedListeItem and LinkedList.\r\n     * The response will be used as the next accumulator.\r\n     */\r\n    callback: (\r\n      accumulator: V,\r\n      currentValue: T,\r\n      currentItem: LinkedListItem<T>,\r\n      list: this,\r\n    ) => V,\r\n    /** Value for the first call of callback */\r\n    initialValue: V,\r\n  ): V;\r\n  public reduceRight<V>(\r\n    callback: (\r\n      accumulator: V | T,\r\n      currentValue: T,\r\n      currentItem: LinkedListItem<T>,\r\n      list: this,\r\n    ) => V,\r\n    initialValue?: V | T,\r\n  ): V | T {\r\n    let current = this.last;\r\n    if (!current) {\r\n      if (!initialValue) {\r\n        throw new TypeError(\r\n          \"Empty accumulator on empty LinkedList is not allowed.\",\r\n        );\r\n      }\r\n      return initialValue;\r\n    }\r\n    if (initialValue === undefined) {\r\n      initialValue = current.value;\r\n      if (!current.before) {\r\n        return initialValue;\r\n      }\r\n      current = current.before;\r\n    }\r\n\r\n    do {\r\n      initialValue = callback(initialValue, current.value, current, this);\r\n      current = current.before;\r\n    } while (current);\r\n    return initialValue;\r\n  }\r\n\r\n  /**\r\n   * Runs callback for every entry and returns true immediately if call of callback returns truthy.\r\n   * @returns `true` once a callback call returns truthy, `false` if none returned truthy.\r\n   */\r\n  public some<C>(\r\n    /** called for every element. If response is truthy, this currentvalue will be returned by `.some()`. */\r\n    callback: (currentValue: T, item: LinkedListItem<T>, list: this) => boolean,\r\n    /** If given, callback function will be bound to thisArg */\r\n    thisArg?: C,\r\n  ): boolean {\r\n    if (thisArg) {\r\n      callback = callback.bind(thisArg);\r\n    }\r\n    for (const [item, value] of this) {\r\n      if (callback(value, item, this)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Joins values within this by given separator. Uses Array#join directly.\r\n   * @see Array#join\r\n   */\r\n  public join(\r\n    /** separator between items in the resulting string */\r\n    separator?: string,\r\n  ): string {\r\n    return [...this.values()].join(separator);\r\n  }\r\n\r\n  /**\r\n   * Concats given values and returns a new LinkedList with all given values.\r\n   * If LinkedList's are given, they will be spread.\r\n   * @see Array#concat\r\n   */\r\n  public concat<V>(\r\n    /** Other values or lists to be concat'ed together */\r\n    ...others: Array<V | LinkedList<V>>\r\n  ): LinkedList<V | T> {\r\n    const newList = new LinkedList<V | T>(this as LinkedList<V | T>);\r\n    for (const other of others) {\r\n      if (other instanceof LinkedList) {\r\n        newList.push(...other.values());\r\n      } else {\r\n        newList.push(other);\r\n      }\r\n    }\r\n    return newList;\r\n  }\r\n\r\n  /**\r\n   * Removes the last LinkedListItem and returns its inner value\r\n   */\r\n  public pop(): T | undefined {\r\n    if (!this.last) {\r\n      return;\r\n    }\r\n    const item = this.last;\r\n    item.unlink();\r\n    return item.value;\r\n  }\r\n\r\n  /**\r\n   * Adds given values on the end of this LinkedList\r\n   */\r\n  public push(\r\n    /** Values to be added */\r\n    ...values: T[]\r\n  ): number {\r\n    for (const value of values) {\r\n      const item = new LinkedListItem(value, this.unlinkCleanup);\r\n      if (!this.first || !this.last) {\r\n        this.first = this.last = item;\r\n      } else {\r\n        this.last.insertBehind(item);\r\n        this.last = item;\r\n      }\r\n      this.length++;\r\n    }\r\n    return this.length;\r\n  }\r\n\r\n  /**\r\n   * Adds given values to the beginning of this LinkedList\r\n   */\r\n  public unshift(\r\n    /** Values to be added */\r\n    ...values: T[]\r\n  ): number {\r\n    for (const value of values) {\r\n      const item = new LinkedListItem(value, this.unlinkCleanup);\r\n      if (!this.last || !this.first) {\r\n        this.first = this.last = item;\r\n      } else {\r\n        item.insertBehind(this.first);\r\n        this.first = item;\r\n      }\r\n      this.length++;\r\n    }\r\n    return this.length;\r\n  }\r\n\r\n  /**\r\n   * Removes first occurrence of value found.\r\n   */\r\n  public remove(\r\n    /** value to remove once */\r\n    value: T,\r\n  ): boolean {\r\n    for (const item of this.keys()) {\r\n      if (item.value === value) {\r\n        item.unlink();\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Removes every occurrance of value within this.\r\n   */\r\n  public removeAllOccurrences(\r\n    /** value to remove completely */\r\n    value: T,\r\n  ): boolean {\r\n    let foundSomethingToDelete = false;\r\n\r\n    for (const item of this.keys()) {\r\n      if (item.value === value) {\r\n        item.unlink();\r\n        foundSomethingToDelete = true;\r\n      }\r\n    }\r\n\r\n    return foundSomethingToDelete;\r\n  }\r\n\r\n  /**\r\n   * Returns and removes first element from LinkedList\r\n   */\r\n  public shift(): T | undefined {\r\n    if (!this.first) {\r\n      return;\r\n    }\r\n    const item = this.first;\r\n    item.unlink();\r\n    return item.value;\r\n  }\r\n\r\n  /**\r\n   * Returns LinkedListItem and value for every entry of this LinkedList\r\n   */\r\n  public *[Symbol.iterator](): IterableIterator<[LinkedListItem<T>, T]> {\r\n    let current = this.first;\r\n    if (!current) {\r\n      return;\r\n    }\r\n    do {\r\n      yield [current, current.value];\r\n      current = current.behind;\r\n    } while (current);\r\n  }\r\n\r\n  /**\r\n   * Returns LinkedListItem and value for every entry of this LinkedList\r\n   * @see LinkedList#Symbol.iterator\r\n   */\r\n  public entries(): IterableIterator<[LinkedListItem<T>, T]> {\r\n    return this[Symbol.iterator]();\r\n  }\r\n\r\n  /**\r\n   * Iterates the LinkedListItem's of this LinkedList\r\n   */\r\n  public *keys(): IterableIterator<LinkedListItem<T>> {\r\n    let current = this.first;\r\n    if (!current) {\r\n      return;\r\n    }\r\n    do {\r\n      yield current;\r\n      current = current.behind;\r\n    } while (current);\r\n  }\r\n\r\n  /**\r\n   * Returns a value for every entry of this LinkedList\r\n   */\r\n  public *values(): IterableIterator<T> {\r\n    let current = this.first;\r\n    if (!current) {\r\n      return;\r\n    }\r\n\r\n    do {\r\n      yield current.value;\r\n      current = current.behind;\r\n    } while (current);\r\n  }\r\n\r\n  /**\r\n   * Returns the item by given index.\r\n   * Supports negative values and will return the item at `LinkedList.size - 1 + index` in that case.\r\n   */\r\n  private getItemByIndex(\r\n    /** Index of item to get from list */\r\n    index: number,\r\n  ): LinkedListItem<T> | undefined {\r\n    if (index === undefined) {\r\n      throw new Error(\"index must be a number!\");\r\n    }\r\n    if (!this.first) {\r\n      return;\r\n    }\r\n    let current: LinkedListItem<T> | undefined;\r\n    if (index > 0) {\r\n      current = this.first;\r\n      while (current && index--) {\r\n        current = current.behind;\r\n      }\r\n    } else if (index < 0) {\r\n      current = this.last;\r\n      while (current && ++index) {\r\n        current = current.before;\r\n      }\r\n    } else {\r\n      return this.first;\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Given to own LinkedListItem's for following jobs regarding an unlink:\r\n   * - If item is first item, set the next item as first item\r\n   * - If item is last item, set the previous item as last item\r\n   * - Decrease length\r\n   */\r\n  private unlinkCleanup = (\r\n    /** Item that has been unlinked */\r\n    item: LinkedListItem<T>,\r\n  ): void => {\r\n    if (this.first === item) {\r\n      this.first = this.first.behind;\r\n    }\r\n    if (this.last === item) {\r\n      this.last = this.last.before;\r\n    }\r\n    this.length--;\r\n  };\r\n}\r\n"]}